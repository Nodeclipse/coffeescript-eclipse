/*
* generated by Xtext
*/
package csep.example.cake.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import csep.services.CoffeeScriptGrammarAccess;

@Singleton
public class CakefileGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class CakefileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Cakefile");
		private final Assignment cTasksAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTasksTaskDeclarationParserRuleCall_0 = (RuleCall)cTasksAssignment.eContents().get(0);
		
		//Cakefile:
		//	tasks+=TaskDeclaration*;
		public ParserRule getRule() { return rule; }

		//tasks+=TaskDeclaration*
		public Assignment getTasksAssignment() { return cTasksAssignment; }

		//TaskDeclaration
		public RuleCall getTasksTaskDeclarationParserRuleCall_0() { return cTasksTaskDeclarationParserRuleCall_0; }
	}

	public class TaskDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TaskDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTASKTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cCALL_STARTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameStringLiteralParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionStringLiteralParserRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final RuleCall cPARAM_STARTTerminalRuleCall_6_0 = (RuleCall)cGroup_6.eContents().get(0);
		private final Assignment cOptionsAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cOptionsIdParserRuleCall_6_1_0 = (RuleCall)cOptionsAssignment_6_1.eContents().get(0);
		private final RuleCall cPARAM_ENDTerminalRuleCall_6_2 = (RuleCall)cGroup_6.eContents().get(2);
		private final RuleCall cFUNC_ARROWTerminalRuleCall_7 = (RuleCall)cGroup.eContents().get(7);
		private final Assignment cBodyAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyBlockParserRuleCall_8_0 = (RuleCall)cBodyAssignment_8.eContents().get(0);
		private final RuleCall cCALL_ENDTerminalRuleCall_9 = (RuleCall)cGroup.eContents().get(9);
		private final RuleCall cTERMINATORTerminalRuleCall_10 = (RuleCall)cGroup.eContents().get(10);
		
		/// **
		// * This grammar may look a bit weird.  It accepts two kinds of task declaration:
		// *  - task "foo", "Just foo", -> ...
		// *  - task "foo", "Just foo", (opts) -> ...
		// * 
		// * They are actually calls of the "task" function with a lambda as its last argument.
		// * The lambda has no parameter in the first case, and a single parameter ("opts") in the second case.
		// * So the lexer inserts extra parens
		// * (CALL_START and CALL_END tokens) to make it a function call.
		// * / TaskDeclaration:
		//	TASK CALL_START name=StringLiteral COMMA description=StringLiteral COMMA (PARAM_START options=Id PARAM_END)?
		//	FUNC_ARROW body=Block CALL_END TERMINATOR;
		public ParserRule getRule() { return rule; }

		//TASK CALL_START name=StringLiteral COMMA description=StringLiteral COMMA (PARAM_START options=Id PARAM_END)? FUNC_ARROW
		//body=Block CALL_END TERMINATOR
		public Group getGroup() { return cGroup; }

		//TASK
		public RuleCall getTASKTerminalRuleCall_0() { return cTASKTerminalRuleCall_0; }

		//CALL_START
		public RuleCall getCALL_STARTTerminalRuleCall_1() { return cCALL_STARTTerminalRuleCall_1; }

		//name=StringLiteral
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//StringLiteral
		public RuleCall getNameStringLiteralParserRuleCall_2_0() { return cNameStringLiteralParserRuleCall_2_0; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3() { return cCOMMATerminalRuleCall_3; }

		//description=StringLiteral
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }

		//StringLiteral
		public RuleCall getDescriptionStringLiteralParserRuleCall_4_0() { return cDescriptionStringLiteralParserRuleCall_4_0; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_5() { return cCOMMATerminalRuleCall_5; }

		//(PARAM_START options=Id PARAM_END)?
		public Group getGroup_6() { return cGroup_6; }

		//PARAM_START
		public RuleCall getPARAM_STARTTerminalRuleCall_6_0() { return cPARAM_STARTTerminalRuleCall_6_0; }

		//options=Id
		public Assignment getOptionsAssignment_6_1() { return cOptionsAssignment_6_1; }

		//Id
		public RuleCall getOptionsIdParserRuleCall_6_1_0() { return cOptionsIdParserRuleCall_6_1_0; }

		//PARAM_END
		public RuleCall getPARAM_ENDTerminalRuleCall_6_2() { return cPARAM_ENDTerminalRuleCall_6_2; }

		//FUNC_ARROW
		public RuleCall getFUNC_ARROWTerminalRuleCall_7() { return cFUNC_ARROWTerminalRuleCall_7; }

		//body=Block
		public Assignment getBodyAssignment_8() { return cBodyAssignment_8; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_8_0() { return cBodyBlockParserRuleCall_8_0; }

		//CALL_END
		public RuleCall getCALL_ENDTerminalRuleCall_9() { return cCALL_ENDTerminalRuleCall_9; }

		//TERMINATOR
		public RuleCall getTERMINATORTerminalRuleCall_10() { return cTERMINATORTerminalRuleCall_10; }
	}
	
	
	private CakefileElements pCakefile;
	private TaskDeclarationElements pTaskDeclaration;
	private TerminalRule tTASK;
	
	private final Grammar grammar;

	private CoffeeScriptGrammarAccess gaCoffeeScript;

	@Inject
	public CakefileGrammarAccess(GrammarProvider grammarProvider,
		CoffeeScriptGrammarAccess gaCoffeeScript) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaCoffeeScript = gaCoffeeScript;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("csep.example.cake.Cakefile".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public CoffeeScriptGrammarAccess getCoffeeScriptGrammarAccess() {
		return gaCoffeeScript;
	}

	
	//Cakefile:
	//	tasks+=TaskDeclaration*;
	public CakefileElements getCakefileAccess() {
		return (pCakefile != null) ? pCakefile : (pCakefile = new CakefileElements());
	}
	
	public ParserRule getCakefileRule() {
		return getCakefileAccess().getRule();
	}

	/// **
	// * This grammar may look a bit weird.  It accepts two kinds of task declaration:
	// *  - task "foo", "Just foo", -> ...
	// *  - task "foo", "Just foo", (opts) -> ...
	// * 
	// * They are actually calls of the "task" function with a lambda as its last argument.
	// * The lambda has no parameter in the first case, and a single parameter ("opts") in the second case.
	// * So the lexer inserts extra parens
	// * (CALL_START and CALL_END tokens) to make it a function call.
	// * / TaskDeclaration:
	//	TASK CALL_START name=StringLiteral COMMA description=StringLiteral COMMA (PARAM_START options=Id PARAM_END)?
	//	FUNC_ARROW body=Block CALL_END TERMINATOR;
	public TaskDeclarationElements getTaskDeclarationAccess() {
		return (pTaskDeclaration != null) ? pTaskDeclaration : (pTaskDeclaration = new TaskDeclarationElements());
	}
	
	public ParserRule getTaskDeclarationRule() {
		return getTaskDeclarationAccess().getRule();
	}

	//terminal TASK:
	//	"task";
	public TerminalRule getTASKRule() {
		return (tTASK != null) ? tTASK : (tTASK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TASK"));
	} 

	//Root:
	//	(Body | Block TERMINATOR)?;
	public CoffeeScriptGrammarAccess.RootElements getRootAccess() {
		return gaCoffeeScript.getRootAccess();
	}
	
	public ParserRule getRootRule() {
		return getRootAccess().getRule();
	}

	//Body:
	//	lines+=Line (TERMINATOR lines+=Line?)*;
	public CoffeeScriptGrammarAccess.BodyElements getBodyAccess() {
		return gaCoffeeScript.getBodyAccess();
	}
	
	public ParserRule getBodyRule() {
		return getBodyAccess().getRule();
	}

	//Line:
	//	Stmt | Expression;
	public CoffeeScriptGrammarAccess.LineElements getLineAccess() {
		return gaCoffeeScript.getLineAccess();
	}
	
	public ParserRule getLineRule() {
		return getLineAccess().getRule();
	}

	//Stmt:
	//	ReturnStmt | ThrowStmt | RequireStmt | Comment | ClassDeclaration | statement=STATEMENT;
	public CoffeeScriptGrammarAccess.StmtElements getStmtAccess() {
		return gaCoffeeScript.getStmtAccess();
	}
	
	public ParserRule getStmtRule() {
		return getStmtAccess().getRule();
	}

	//Comment:
	//	comment=HERECOMMENT;
	public CoffeeScriptGrammarAccess.CommentElements getCommentAccess() {
		return gaCoffeeScript.getCommentAccess();
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}

	/// **
	// * Treat it a special way, because it takes care of import
	// * / RequireStmt:
	//	=> (importedNamespace=Id EQUAL "require") CALL_START uri=STRING CALL_END;
	public CoffeeScriptGrammarAccess.RequireStmtElements getRequireStmtAccess() {
		return gaCoffeeScript.getRequireStmtAccess();
	}
	
	public ParserRule getRequireStmtRule() {
		return getRequireStmtAccess().getRule();
	}

	//ReturnStmt:
	//	{ReturnStmt} RETURN expression=Expression? (POST_IF condition=Expression)?;
	public CoffeeScriptGrammarAccess.ReturnStmtElements getReturnStmtAccess() {
		return gaCoffeeScript.getReturnStmtAccess();
	}
	
	public ParserRule getReturnStmtRule() {
		return getReturnStmtAccess().getRule();
	}

	//ThrowStmt:
	//	THROW exp=Expression;
	public CoffeeScriptGrammarAccess.ThrowStmtElements getThrowStmtAccess() {
		return gaCoffeeScript.getThrowStmtAccess();
	}
	
	public ParserRule getThrowStmtRule() {
		return getThrowStmtAccess().getRule();
	}

	/// **
	// * Coffeescript is permissive, it can be any expression, but we want to be able to check it as crossref
	// * / SuperClass:
	//	IdRef | Property;
	public CoffeeScriptGrammarAccess.SuperClassElements getSuperClassAccess() {
		return gaCoffeeScript.getSuperClassAccess();
	}
	
	public ParserRule getSuperClassRule() {
		return getSuperClassAccess().getRule();
	}

	//ClassDeclaration:
	//	{ClassDeclaration} CLASS (body=Block | EXTENDS extend=SuperClass body=Block? | name=(Id | Property) (EXTENDS
	//	extend=SuperClass)? body=Block)?;
	public CoffeeScriptGrammarAccess.ClassDeclarationElements getClassDeclarationAccess() {
		return gaCoffeeScript.getClassDeclarationAccess();
	}
	
	public ParserRule getClassDeclarationRule() {
		return getClassDeclarationAccess().getRule();
	}

	/// **
	// * FIXME: it should be the same as ClassDeclaration, but it would result in a non-LL decision,
	// * so I just removed the problematic options (a class body and a name or a superclass is required).
	// * / AssignedClassDeclaration:
	//	{ClassDeclaration} CLASS (EXTENDS extend=SuperClass body=Block | name=(Id | Property) (EXTENDS extend=SuperClass)?
	//	body=Block)?;
	public CoffeeScriptGrammarAccess.AssignedClassDeclarationElements getAssignedClassDeclarationAccess() {
		return gaCoffeeScript.getAssignedClassDeclarationAccess();
	}
	
	public ParserRule getAssignedClassDeclarationRule() {
		return getAssignedClassDeclarationAccess().getRule();
	}

	//Expression:
	//	Postfix;
	public CoffeeScriptGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaCoffeeScript.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// right-assoc
	//// Note: the lexer seems to know it should give a POST_IF token here
	//Postfix returns Expression: //Assignment postfix+=(PostfixIf | ForBody)?;
	//	Assignment (POST_IF {If.dummy=current} condition=Expression | FOR {For.dummy=current} body=ForBody | WHILE
	//	{While.dummy=current} body=Expression (WHEN when=Expression)? | UNTIL {Until.dummy=current} body=Expression (WHEN
	//	when=Expression)?)?;
	public CoffeeScriptGrammarAccess.PostfixElements getPostfixAccess() {
		return gaCoffeeScript.getPostfixAccess();
	}
	
	public ParserRule getPostfixRule() {
		return getPostfixAccess().getRule();
	}

	//ForBody returns Expression: //FIXME: Range |
	//	OWN? indexes+=ForValue (COMMA indexes+=ForValue)* source=ForSource;
	public CoffeeScriptGrammarAccess.ForBodyElements getForBodyAccess() {
		return gaCoffeeScript.getForBodyAccess();
	}
	
	public ParserRule getForBodyRule() {
		return getForBodyAccess().getRule();
	}

	////FIXME | Array | Dictionary;
	//ForValue:
	//	Id;
	public CoffeeScriptGrammarAccess.ForValueElements getForValueAccess() {
		return gaCoffeeScript.getForValueAccess();
	}
	
	public ParserRule getForValueRule() {
		return getForValueAccess().getRule();
	}

	//ForSource:
	//	{ForSource} (FOROF source=Expression (WHEN when=Expression)? | FORIN source=Expression (WHEN when=Expression (BY
	//	by=Expression)? | BY by=Expression (WHEN when=Expression)?)?);
	public CoffeeScriptGrammarAccess.ForSourceElements getForSourceAccess() {
		return gaCoffeeScript.getForSourceAccess();
	}
	
	public ParserRule getForSourceRule() {
		return getForSourceAccess().getRule();
	}

	//Range:
	//	=> (LBRACKET start=Expression (DOT_DOT | ELLIPSIS)) end=Expression RBRACKET;
	public CoffeeScriptGrammarAccess.RangeElements getRangeAccess() {
		return gaCoffeeScript.getRangeAccess();
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//Assignment returns Expression:
	//	=> (left=Assignable operator=(EQUAL | COMPOUND_ASSIGN)) right=Assigned | LogicOp;
	public CoffeeScriptGrammarAccess.AssignmentElements getAssignmentAccess() {
		return gaCoffeeScript.getAssignmentAccess();
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//Assigned returns Expression:
	//	Expression | INDENT Expression OUTDENT | AssignedClassDeclaration;
	public CoffeeScriptGrammarAccess.AssignedElements getAssignedAccess() {
		return gaCoffeeScript.getAssignedAccess();
	}
	
	public ParserRule getAssignedRule() {
		return getAssignedAccess().getRule();
	}

	//LogicOp returns Expression:
	//	CompareOp (=> ({BinaryExp.left=current} operator=LOGIC) right=CompareOp)*;
	public CoffeeScriptGrammarAccess.LogicOpElements getLogicOpAccess() {
		return gaCoffeeScript.getLogicOpAccess();
	}
	
	public ParserRule getLogicOpRule() {
		return getLogicOpAccess().getRule();
	}

	//CompareOp returns Expression:
	//	RelationOp (=> ({BinaryExp.left=current} operator=COMPARE) right=RelationOp)*;
	public CoffeeScriptGrammarAccess.CompareOpElements getCompareOpAccess() {
		return gaCoffeeScript.getCompareOpAccess();
	}
	
	public ParserRule getCompareOpRule() {
		return getCompareOpAccess().getRule();
	}

	//RelationOp returns Expression:
	//	ShiftOp (=> ({BinaryExp.left=current} operator=RELATION) right=ShiftOp)*;
	public CoffeeScriptGrammarAccess.RelationOpElements getRelationOpAccess() {
		return gaCoffeeScript.getRelationOpAccess();
	}
	
	public ParserRule getRelationOpRule() {
		return getRelationOpAccess().getRule();
	}

	//ShiftOp returns Expression:
	//	AdditiveOp (=> ({BinaryExp.left=current} operator=SHIFT) right=AdditiveOp)*;
	public CoffeeScriptGrammarAccess.ShiftOpElements getShiftOpAccess() {
		return gaCoffeeScript.getShiftOpAccess();
	}
	
	public ParserRule getShiftOpRule() {
		return getShiftOpAccess().getRule();
	}

	//AdditiveOp returns Expression:
	//	MathOp (=> ({BinaryExp.left=current} operator=(PLUS | MINUS)) right=MathOp)*;
	public CoffeeScriptGrammarAccess.AdditiveOpElements getAdditiveOpAccess() {
		return gaCoffeeScript.getAdditiveOpAccess();
	}
	
	public ParserRule getAdditiveOpRule() {
		return getAdditiveOpAccess().getRule();
	}

	//MathOp returns Expression:
	//	UnaryOp (=> ({BinaryExp.left=current} operator=MATH) right=UnaryOp)*;
	public CoffeeScriptGrammarAccess.MathOpElements getMathOpAccess() {
		return gaCoffeeScript.getMathOpAccess();
	}
	
	public ParserRule getMathOpRule() {
		return getMathOpAccess().getRule();
	}

	//UnaryOp returns Expression:
	//	(UNARY | PLUS | MINUS) Expression | (PLUS_PLUS | MINUS_MINUS) Variable | // FIXME: postfix increment
	//	Application QUESTION?;
	public CoffeeScriptGrammarAccess.UnaryOpElements getUnaryOpAccess() {
		return gaCoffeeScript.getUnaryOpAccess();
	}
	
	public ParserRule getUnaryOpRule() {
		return getUnaryOpAccess().getRule();
	}

	//// Nested function calls and property accesses -- I couldn't come up with a better name
	//Application:
	//	{SuperCall} (SUPER (CALL_START args=ArgList CALL_END)?) | value=PrimaryExpression features+=FeatureCall*;
	public CoffeeScriptGrammarAccess.ApplicationElements getApplicationAccess() {
		return gaCoffeeScript.getApplicationAccess();
	}
	
	public ParserRule getApplicationRule() {
		return getApplicationAccess().getRule();
	}

	//FeatureCall:
	//	FunctionCall | PropertyAccess;
	public CoffeeScriptGrammarAccess.FeatureCallElements getFeatureCallAccess() {
		return gaCoffeeScript.getFeatureCallAccess();
	}
	
	public ParserRule getFeatureCallRule() {
		return getFeatureCallAccess().getRule();
	}

	//FunctionCall:
	//	{FunctionCall} FUNC_EXIST? CALL_START args=ArgList CALL_END;
	public CoffeeScriptGrammarAccess.FunctionCallElements getFunctionCallAccess() {
		return gaCoffeeScript.getFunctionCallAccess();
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//PropertyAccess:
	//	NamedPropertyAccess | IndexedPropertyAccess;
	public CoffeeScriptGrammarAccess.PropertyAccessElements getPropertyAccessAccess() {
		return gaCoffeeScript.getPropertyAccessAccess();
	}
	
	public ParserRule getPropertyAccessRule() {
		return getPropertyAccessAccess().getRule();
	}

	//ThisProperty:
	//	AT_SIGIL Id;
	public CoffeeScriptGrammarAccess.ThisPropertyElements getThisPropertyAccess() {
		return gaCoffeeScript.getThisPropertyAccess();
	}
	
	public ParserRule getThisPropertyRule() {
		return getThisPropertyAccess().getRule();
	}

	//NamedPropertyAccess:
	//	accessor=(DOT | QUESTION_DOT) name=Id | accessor=DOUBLE_COLON name=Id?;
	public CoffeeScriptGrammarAccess.NamedPropertyAccessElements getNamedPropertyAccessAccess() {
		return gaCoffeeScript.getNamedPropertyAccessAccess();
	}
	
	public ParserRule getNamedPropertyAccessRule() {
		return getNamedPropertyAccessAccess().getRule();
	}

	//IndexedPropertyAccess:
	//	INDEX_START index=Index INDEX_END;
	public CoffeeScriptGrammarAccess.IndexedPropertyAccessElements getIndexedPropertyAccessAccess() {
		return gaCoffeeScript.getIndexedPropertyAccessAccess();
	}
	
	public ParserRule getIndexedPropertyAccessRule() {
		return getIndexedPropertyAccessAccess().getRule();
	}

	//Index:
	//	=> dots=(DOT_DOT | ELLIPSIS) end=Expression | => (start=Expression dots=(DOT_DOT | ELLIPSIS)) end=Expression? |
	//	exp=Expression;
	public CoffeeScriptGrammarAccess.IndexElements getIndexAccess() {
		return gaCoffeeScript.getIndexAccess();
	}
	
	public ParserRule getIndexRule() {
		return getIndexAccess().getRule();
	}

	//// Try Range before Array
	//PrimaryExpression:
	//	IfExp | Parenthetical | Literal | Range | Array | Dictionary | Lambda | ThisProperty | {ThisAlone} THIS | {For} (FOR
	//	loop=ForBody body=Block) | {While} (WHILE loop=Expression (WHEN when=Expression)? body=Block) | {Until} (UNTIL
	//	loop=Expression (WHEN when=Expression)? body=Block) | {Loop} (LOOP body=Block) | {TryCatch} (TRY body=Block (CATCH
	//	exception=Id catchBlock=Block (FINALLY finallyBlock=Block)? | FINALLY finallyBlock=Block)?) | {Switch} (SWITCH
	//	exp=Expression? INDENT cases+=Case* (ELSE elseBlock=Block)? OUTDENT) | IdRef;
	public CoffeeScriptGrammarAccess.PrimaryExpressionElements getPrimaryExpressionAccess() {
		return gaCoffeeScript.getPrimaryExpressionAccess();
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//Block:
	//	{Block} INDENT Body? OUTDENT;
	public CoffeeScriptGrammarAccess.BlockElements getBlockAccess() {
		return gaCoffeeScript.getBlockAccess();
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// a switch case (called When in coffeescript)
	//Case:
	//	LEADING_WHEN whens+=Expression (COMMA whens+=Expression)* then=Block TERMINATOR?;
	public CoffeeScriptGrammarAccess.CaseElements getCaseAccess() {
		return gaCoffeeScript.getCaseAccess();
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}

	//IfExp:
	//	blocks+=CondBlock (ELSE blocks+=CondBlock)* (ELSE defaultBlock=Block)?;
	public CoffeeScriptGrammarAccess.IfExpElements getIfExpAccess() {
		return gaCoffeeScript.getIfExpAccess();
	}
	
	public ParserRule getIfExpRule() {
		return getIfExpAccess().getRule();
	}

	//// IF can be 'if' or 'unless'
	//CondBlock:
	//	operator=IF condition=Expression action=Block;
	public CoffeeScriptGrammarAccess.CondBlockElements getCondBlockAccess() {
		return gaCoffeeScript.getCondBlockAccess();
	}
	
	public ParserRule getCondBlockRule() {
		return getCondBlockAccess().getRule();
	}

	//IdRef:
	//	val=[Id|IDENTIFIER];
	public CoffeeScriptGrammarAccess.IdRefElements getIdRefAccess() {
		return gaCoffeeScript.getIdRefAccess();
	}
	
	public ParserRule getIdRefRule() {
		return getIdRefAccess().getRule();
	}

	//Id:
	//	name=IDENTIFIER;
	public CoffeeScriptGrammarAccess.IdElements getIdAccess() {
		return gaCoffeeScript.getIdAccess();
	}
	
	public ParserRule getIdRule() {
		return getIdAccess().getRule();
	}

	//Property:
	//	=> (IdRef accessor=(DOT | DOUBLE_COLON | QUESTION_DOT)) prop=Id // FIXME: property is actually "Expression Accessor"
	//	| => (IdRef INDEX_START) index=Index INDEX_END;
	public CoffeeScriptGrammarAccess.PropertyElements getPropertyAccess() {
		return gaCoffeeScript.getPropertyAccess();
	}
	
	public ParserRule getPropertyRule() {
		return getPropertyAccess().getRule();
	}

	//Variable:
	//	Id | (AT_SIGIL | THIS DOT) Id (DOT props+=Id)* | Property;
	public CoffeeScriptGrammarAccess.VariableElements getVariableAccess() {
		return gaCoffeeScript.getVariableAccess();
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	/// ** An array that can be on the left-hand side of an assignment * / AssignableArray:
	//	LBRACKET AssignableArgList RBRACKET;
	public CoffeeScriptGrammarAccess.AssignableArrayElements getAssignableArrayAccess() {
		return gaCoffeeScript.getAssignableArrayAccess();
	}
	
	public ParserRule getAssignableArrayRule() {
		return getAssignableArrayAccess().getRule();
	}

	//AssignableArgList:
	//	args+=AssignableArg (COMMA args+=AssignableArg)*;
	public CoffeeScriptGrammarAccess.AssignableArgListElements getAssignableArgListAccess() {
		return gaCoffeeScript.getAssignableArgListAccess();
	}
	
	public ParserRule getAssignableArgListRule() {
		return getAssignableArgListAccess().getRule();
	}

	//AssignableArg:
	//	arg=Assignable splat?=ELLIPSIS?;
	public CoffeeScriptGrammarAccess.AssignableArgElements getAssignableArgAccess() {
		return gaCoffeeScript.getAssignableArgAccess();
	}
	
	public ParserRule getAssignableArgRule() {
		return getAssignableArgAccess().getRule();
	}

	//Assignable:
	//	Variable | Dictionary | AssignableArray;
	public CoffeeScriptGrammarAccess.AssignableElements getAssignableAccess() {
		return gaCoffeeScript.getAssignableAccess();
	}
	
	public ParserRule getAssignableRule() {
		return getAssignableAccess().getRule();
	}

	/// *
	//	 * FIXME: handle more complex assignables
	//	* / Arg:
	//	exp=Expression splat?=ELLIPSIS?;
	public CoffeeScriptGrammarAccess.ArgElements getArgAccess() {
		return gaCoffeeScript.getArgAccess();
	}
	
	public ParserRule getArgRule() {
		return getArgAccess().getRule();
	}

	//ArgLine:
	//	head=Arg (COMMA tail+=Arg)* COMMA?;
	public CoffeeScriptGrammarAccess.ArgLineElements getArgLineAccess() {
		return gaCoffeeScript.getArgLineAccess();
	}
	
	public ParserRule getArgLineRule() {
		return getArgLineAccess().getRule();
	}

	//ExplicitArgList:
	//	lines+=ArgLine (TERMINATOR lines+=ArgLine | INDENT lines+=ArgLine OUTDENT)*;
	public CoffeeScriptGrammarAccess.ExplicitArgListElements getExplicitArgListAccess() {
		return gaCoffeeScript.getExplicitArgListAccess();
	}
	
	public ParserRule getExplicitArgListRule() {
		return getExplicitArgListAccess().getRule();
	}

	//ArgList:
	//	{ArgList} (dummy=ExplicitArgList | INDENT dummy=ExplicitArgList OUTDENT)?;
	public CoffeeScriptGrammarAccess.ArgListElements getArgListAccess() {
		return gaCoffeeScript.getArgListAccess();
	}
	
	public ParserRule getArgListRule() {
		return getArgListAccess().getRule();
	}

	//Array:
	//	LBRACKET ArgList RBRACKET;
	public CoffeeScriptGrammarAccess.ArrayElements getArrayAccess() {
		return gaCoffeeScript.getArrayAccess();
	}
	
	public ParserRule getArrayRule() {
		return getArrayAccess().getRule();
	}

	//// Object in coffeescript
	//Dictionary:
	//	LCURLY DictItems RCURLY;
	public CoffeeScriptGrammarAccess.DictionaryElements getDictionaryAccess() {
		return gaCoffeeScript.getDictionaryAccess();
	}
	
	public ParserRule getDictionaryRule() {
		return getDictionaryAccess().getRule();
	}

	//DictItems:
	//	{DictItems} (dummy=ExplicitDictItems | INDENT dummy=ExplicitDictItems OUTDENT)?;
	public CoffeeScriptGrammarAccess.DictItemsElements getDictItemsAccess() {
		return gaCoffeeScript.getDictItemsAccess();
	}
	
	public ParserRule getDictItemsRule() {
		return getDictItemsAccess().getRule();
	}

	//ExplicitDictItems:
	//	lines+=DictLine (TERMINATOR lines+=DictLine | INDENT lines+=DictLine OUTDENT)*;
	public CoffeeScriptGrammarAccess.ExplicitDictItemsElements getExplicitDictItemsAccess() {
		return gaCoffeeScript.getExplicitDictItemsAccess();
	}
	
	public ParserRule getExplicitDictItemsRule() {
		return getExplicitDictItemsAccess().getRule();
	}

	//DictLine:
	//	head=DictItem (COMMA tail+=DictItem)* COMMA?;
	public CoffeeScriptGrammarAccess.DictLineElements getDictLineAccess() {
		return gaCoffeeScript.getDictLineAccess();
	}
	
	public ParserRule getDictLineRule() {
		return getDictLineAccess().getRule();
	}

	//DictItem:
	//	{DictItem} key=DictKey (COLON (value=Expression | INDENT value=Expression OUTDENT))?;
	public CoffeeScriptGrammarAccess.DictItemElements getDictItemAccess() {
		return gaCoffeeScript.getDictItemAccess();
	}
	
	public ParserRule getDictItemRule() {
		return getDictItemAccess().getRule();
	}

	//DictKey:
	//	Literal | Id;
	public CoffeeScriptGrammarAccess.DictKeyElements getDictKeyAccess() {
		return gaCoffeeScript.getDictKeyAccess();
	}
	
	public ParserRule getDictKeyRule() {
		return getDictKeyAccess().getRule();
	}

	//// Code in coffeescript
	//Lambda:
	//	(PARAM_START (params+=Param (COMMA params+=Param)*)? PARAM_END)? (FUNC_ARROW | BOUND_FUNC_ARROW) body=Block;
	public CoffeeScriptGrammarAccess.LambdaElements getLambdaAccess() {
		return gaCoffeeScript.getLambdaAccess();
	}
	
	public ParserRule getLambdaRule() {
		return getLambdaAccess().getRule();
	}

	//Param:
	//	(Id | Array | Dictionary | ThisProperty) (splat?=ELLIPSIS | EQUAL defaultValue=Expression)?;
	public CoffeeScriptGrammarAccess.ParamElements getParamAccess() {
		return gaCoffeeScript.getParamAccess();
	}
	
	public ParserRule getParamRule() {
		return getParamAccess().getRule();
	}

	//NumberLiteral:
	//	{NumberLiteral} NUMBER;
	public CoffeeScriptGrammarAccess.NumberLiteralElements getNumberLiteralAccess() {
		return gaCoffeeScript.getNumberLiteralAccess();
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//StringLiteral:
	//	{StringLiteral} STRING;
	public CoffeeScriptGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaCoffeeScript.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//BoolLiteral:
	//	{BoolLiteral} BOOL;
	public CoffeeScriptGrammarAccess.BoolLiteralElements getBoolLiteralAccess() {
		return gaCoffeeScript.getBoolLiteralAccess();
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}

	//JSLiteral:
	//	{JSLiteral} JS;
	public CoffeeScriptGrammarAccess.JSLiteralElements getJSLiteralAccess() {
		return gaCoffeeScript.getJSLiteralAccess();
	}
	
	public ParserRule getJSLiteralRule() {
		return getJSLiteralAccess().getRule();
	}

	//RegexLiteral:
	//	{RegexLiteral} REGEX;
	public CoffeeScriptGrammarAccess.RegexLiteralElements getRegexLiteralAccess() {
		return gaCoffeeScript.getRegexLiteralAccess();
	}
	
	public ParserRule getRegexLiteralRule() {
		return getRegexLiteralAccess().getRule();
	}

	//Literal:
	//	NumberLiteral | StringLiteral | BoolLiteral | JSLiteral | RegexLiteral;
	public CoffeeScriptGrammarAccess.LiteralElements getLiteralAccess() {
		return gaCoffeeScript.getLiteralAccess();
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//Parenthetical:
	//	=> (LPAREN INDENT) content=Body OUTDENT RPAREN | LPAREN content=Body RPAREN;
	public CoffeeScriptGrammarAccess.ParentheticalElements getParentheticalAccess() {
		return gaCoffeeScript.getParentheticalAccess();
	}
	
	public ParserRule getParentheticalRule() {
		return getParentheticalAccess().getRule();
	}

	//// terminals {{{
	/// * Note: these are only to enable debugging with Antlworks,
	// * The actual tokens are provided by the lexer.
	// * The debugger is smart in some cases, and emits different tokens
	// * for the same character depending on the context.
	// * For example
	// * "(1)" -> LPAREN NUMBER RPAREN
	// * "func()" -> IDENTIFIER CALL_START CALL_END
	// * But the debugger expects different strings for the tokens,
	// * so special ones get an additional asterisk:
	// * LPAREN: '('
	// * CALL_START: '(*'
	// * 
	// * To imitate indentation while debugging, use INDENT and OUTDENT, like this
	// *   if maybe {*
	// *     action()
	// *   *}
	// *   else {*
	// *     wait()
	// *   *}
	// * / // compound terminals at the beginning to they don't get shadowed
	//terminal ELLIPSIS:
	//	"...";
	public TerminalRule getELLIPSISRule() {
		return gaCoffeeScript.getELLIPSISRule();
	} 

	//terminal DOT_DOT:
	//	"..";
	public TerminalRule getDOT_DOTRule() {
		return gaCoffeeScript.getDOT_DOTRule();
	} 

	//terminal DOUBLE_COLON:
	//	"::";
	public TerminalRule getDOUBLE_COLONRule() {
		return gaCoffeeScript.getDOUBLE_COLONRule();
	} 

	//terminal SHIFT:
	//	"<<" | ">>";
	public TerminalRule getSHIFTRule() {
		return gaCoffeeScript.getSHIFTRule();
	} 

	//terminal BOUND_FUNC_ARROW:
	//	"=>";
	public TerminalRule getBOUND_FUNC_ARROWRule() {
		return gaCoffeeScript.getBOUND_FUNC_ARROWRule();
	} 

	//terminal FUNC_ARROW:
	//	"->";
	public TerminalRule getFUNC_ARROWRule() {
		return gaCoffeeScript.getFUNC_ARROWRule();
	} 

	//terminal COMPARE:
	//	"<" | "==" | ">" | "<=" | ">=" | "!=";
	public TerminalRule getCOMPARERule() {
		return gaCoffeeScript.getCOMPARERule();
	} 

	//terminal COMPOUND_ASSIGN:
	//	"+=" | "-=";
	public TerminalRule getCOMPOUND_ASSIGNRule() {
		return gaCoffeeScript.getCOMPOUND_ASSIGNRule();
	} 

	//terminal PLUS_PLUS:
	//	"++";
	public TerminalRule getPLUS_PLUSRule() {
		return gaCoffeeScript.getPLUS_PLUSRule();
	} 

	//terminal MINUS_MINUS:
	//	"--";
	public TerminalRule getMINUS_MINUSRule() {
		return gaCoffeeScript.getMINUS_MINUSRule();
	} 

	//terminal PARAM_END:
	//	"**)";
	public TerminalRule getPARAM_ENDRule() {
		return gaCoffeeScript.getPARAM_ENDRule();
	} 

	//terminal PARAM_START:
	//	"(**";
	public TerminalRule getPARAM_STARTRule() {
		return gaCoffeeScript.getPARAM_STARTRule();
	} 

	//terminal AT_SIGIL:
	//	"@";
	public TerminalRule getAT_SIGILRule() {
		return gaCoffeeScript.getAT_SIGILRule();
	} 

	//terminal BOOL:
	//	"true" | "false" | "undefined" | "null" | "on" | "no" | "yes" | "off";
	public TerminalRule getBOOLRule() {
		return gaCoffeeScript.getBOOLRule();
	} 

	//terminal BY:
	//	"by";
	public TerminalRule getBYRule() {
		return gaCoffeeScript.getBYRule();
	} 

	//terminal CALL_END:
	//	"*)";
	public TerminalRule getCALL_ENDRule() {
		return gaCoffeeScript.getCALL_ENDRule();
	} 

	//terminal CALL_START:
	//	"(*";
	public TerminalRule getCALL_STARTRule() {
		return gaCoffeeScript.getCALL_STARTRule();
	} 

	//terminal CATCH:
	//	"catch";
	public TerminalRule getCATCHRule() {
		return gaCoffeeScript.getCATCHRule();
	} 

	//terminal CLASS:
	//	"class";
	public TerminalRule getCLASSRule() {
		return gaCoffeeScript.getCLASSRule();
	} 

	//terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return gaCoffeeScript.getCOLONRule();
	} 

	//terminal COLON_SLASH:
	//	"dummy COLON_SLASH";
	public TerminalRule getCOLON_SLASHRule() {
		return gaCoffeeScript.getCOLON_SLASHRule();
	} 

	//terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return gaCoffeeScript.getCOMMARule();
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return gaCoffeeScript.getDOTRule();
	} 

	//terminal ELSE:
	//	"else";
	public TerminalRule getELSERule() {
		return gaCoffeeScript.getELSERule();
	} 

	//terminal EQUAL:
	//	"=";
	public TerminalRule getEQUALRule() {
		return gaCoffeeScript.getEQUALRule();
	} 

	//terminal EXTENDS:
	//	"extends";
	public TerminalRule getEXTENDSRule() {
		return gaCoffeeScript.getEXTENDSRule();
	} 

	//terminal FINALLY:
	//	"finally";
	public TerminalRule getFINALLYRule() {
		return gaCoffeeScript.getFINALLYRule();
	} 

	//terminal FOR:
	//	"for";
	public TerminalRule getFORRule() {
		return gaCoffeeScript.getFORRule();
	} 

	//terminal FORIN:
	//	"in";
	public TerminalRule getFORINRule() {
		return gaCoffeeScript.getFORINRule();
	} 

	//terminal FOROF:
	//	"of";
	public TerminalRule getFOROFRule() {
		return gaCoffeeScript.getFOROFRule();
	} 

	//terminal FUNC_EXIST:
	//	"dummy FUNC_EXIST";
	public TerminalRule getFUNC_EXISTRule() {
		return gaCoffeeScript.getFUNC_EXISTRule();
	} 

	//terminal HERECOMMENT:
	//	"dummy HERECOMMENT";
	public TerminalRule getHERECOMMENTRule() {
		return gaCoffeeScript.getHERECOMMENTRule();
	} 

	//terminal IF:
	//	"if" | "unless";
	public TerminalRule getIFRule() {
		return gaCoffeeScript.getIFRule();
	} 

	//terminal INDENT:
	//	"{*";
	public TerminalRule getINDENTRule() {
		return gaCoffeeScript.getINDENTRule();
	} 

	//terminal INDEX_END:
	//	"*]";
	public TerminalRule getINDEX_ENDRule() {
		return gaCoffeeScript.getINDEX_ENDRule();
	} 

	//terminal INDEX_PROTO:
	//	"dummy INDEX_PROTO";
	public TerminalRule getINDEX_PROTORule() {
		return gaCoffeeScript.getINDEX_PROTORule();
	} 

	//terminal INDEX_SOAK:
	//	"dummy INDEX_SOAK";
	public TerminalRule getINDEX_SOAKRule() {
		return gaCoffeeScript.getINDEX_SOAKRule();
	} 

	//terminal INDEX_START:
	//	"[*";
	public TerminalRule getINDEX_STARTRule() {
		return gaCoffeeScript.getINDEX_STARTRule();
	} 

	//terminal JS:
	//	"dummy JS";
	public TerminalRule getJSRule() {
		return gaCoffeeScript.getJSRule();
	} 

	//terminal LBRACKET:
	//	"[";
	public TerminalRule getLBRACKETRule() {
		return gaCoffeeScript.getLBRACKETRule();
	} 

	//terminal LCURLY:
	//	"dummy LCURLY";
	public TerminalRule getLCURLYRule() {
		return gaCoffeeScript.getLCURLYRule();
	} 

	//terminal LEADING_WHEN:
	//	"dummy LEADING_WHEN";
	public TerminalRule getLEADING_WHENRule() {
		return gaCoffeeScript.getLEADING_WHENRule();
	} 

	//terminal LOGIC:
	//	"&&" | "||";
	public TerminalRule getLOGICRule() {
		return gaCoffeeScript.getLOGICRule();
	} 

	//terminal LOOP:
	//	"loop";
	public TerminalRule getLOOPRule() {
		return gaCoffeeScript.getLOOPRule();
	} 

	//terminal LPAREN:
	//	"(";
	public TerminalRule getLPARENRule() {
		return gaCoffeeScript.getLPARENRule();
	} 

	//terminal MATH:
	//	"*" | "/";
	public TerminalRule getMATHRule() {
		return gaCoffeeScript.getMATHRule();
	} 

	//terminal MINUS:
	//	"-";
	public TerminalRule getMINUSRule() {
		return gaCoffeeScript.getMINUSRule();
	} 

	//terminal NEW:
	//	"new";
	public TerminalRule getNEWRule() {
		return gaCoffeeScript.getNEWRule();
	} 

	//terminal NUMBER returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getNUMBERRule() {
		return gaCoffeeScript.getNUMBERRule();
	} 

	//terminal OUTDENT:
	//	"*}";
	public TerminalRule getOUTDENTRule() {
		return gaCoffeeScript.getOUTDENTRule();
	} 

	//terminal OWN:
	//	"own";
	public TerminalRule getOWNRule() {
		return gaCoffeeScript.getOWNRule();
	} 

	//terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return gaCoffeeScript.getPLUSRule();
	} 

	//// practically the same as IF
	//terminal POST_IF:
	//	"dummy POST_IF";
	public TerminalRule getPOST_IFRule() {
		return gaCoffeeScript.getPOST_IFRule();
	} 

	//terminal QUESTION:
	//	"?";
	public TerminalRule getQUESTIONRule() {
		return gaCoffeeScript.getQUESTIONRule();
	} 

	//terminal QUESTION_DOT:
	//	"?.";
	public TerminalRule getQUESTION_DOTRule() {
		return gaCoffeeScript.getQUESTION_DOTRule();
	} 

	//terminal RBRACKET:
	//	"]";
	public TerminalRule getRBRACKETRule() {
		return gaCoffeeScript.getRBRACKETRule();
	} 

	//terminal RCURLY:
	//	"dummy RCURLY";
	public TerminalRule getRCURLYRule() {
		return gaCoffeeScript.getRCURLYRule();
	} 

	//terminal REGEX:
	//	"///"->"///";
	public TerminalRule getREGEXRule() {
		return gaCoffeeScript.getREGEXRule();
	} 

	//terminal RELATION:
	//	"in" | "of" | "instanceof";
	public TerminalRule getRELATIONRule() {
		return gaCoffeeScript.getRELATIONRule();
	} 

	//terminal RETURN:
	//	"return";
	public TerminalRule getRETURNRule() {
		return gaCoffeeScript.getRETURNRule();
	} 

	//terminal RPAREN:
	//	")";
	public TerminalRule getRPARENRule() {
		return gaCoffeeScript.getRPARENRule();
	} 

	//terminal STATEMENT:
	//	"break" | "continue" | "debugger";
	public TerminalRule getSTATEMENTRule() {
		return gaCoffeeScript.getSTATEMENTRule();
	} 

	//terminal STRING:
	//	"\'\'\'"->"\'\'\'" | "\'" (!"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))*)?
	//	"\'" | "\"\"\""->"\"\"\"" | "\"" (!"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" |
	//	"\""))*)? "\"";
	public TerminalRule getSTRINGRule() {
		return gaCoffeeScript.getSTRINGRule();
	} 

	//terminal SUPER:
	//	"super";
	public TerminalRule getSUPERRule() {
		return gaCoffeeScript.getSUPERRule();
	} 

	//terminal SWITCH:
	//	"switch";
	public TerminalRule getSWITCHRule() {
		return gaCoffeeScript.getSWITCHRule();
	} 

	//terminal TERMINATOR:
	//	"\n"+;
	public TerminalRule getTERMINATORRule() {
		return gaCoffeeScript.getTERMINATORRule();
	} 

	//terminal THEN:
	//	"then";
	public TerminalRule getTHENRule() {
		return gaCoffeeScript.getTHENRule();
	} 

	//terminal THIS:
	//	"this";
	public TerminalRule getTHISRule() {
		return gaCoffeeScript.getTHISRule();
	} 

	//terminal THROW:
	//	"throw";
	public TerminalRule getTHROWRule() {
		return gaCoffeeScript.getTHROWRule();
	} 

	//terminal TRY:
	//	"try";
	public TerminalRule getTRYRule() {
		return gaCoffeeScript.getTRYRule();
	} 

	//terminal UNARY:
	//	"!" | "~";
	public TerminalRule getUNARYRule() {
		return gaCoffeeScript.getUNARYRule();
	} 

	//terminal UNTIL:
	//	"until";
	public TerminalRule getUNTILRule() {
		return gaCoffeeScript.getUNTILRule();
	} 

	//terminal WHEN:
	//	"when";
	public TerminalRule getWHENRule() {
		return gaCoffeeScript.getWHENRule();
	} 

	//terminal WHILE:
	//	"while";
	public TerminalRule getWHILERule() {
		return gaCoffeeScript.getWHILERule();
	} 

	//// These tokens are used only by syntax coloring
	//terminal LOGIC_WORD:
	//	"and" | "or";
	public TerminalRule getLOGIC_WORDRule() {
		return gaCoffeeScript.getLOGIC_WORDRule();
	} 

	//terminal COMPARE_WORD:
	//	"isnt" | "is";
	public TerminalRule getCOMPARE_WORDRule() {
		return gaCoffeeScript.getCOMPARE_WORDRule();
	} 

	//terminal UNARY_WORD:
	//	"new" | "do" | "not";
	public TerminalRule getUNARY_WORDRule() {
		return gaCoffeeScript.getUNARY_WORDRule();
	} 

	//terminal ML_COMMENT:
	//	"###" !"#"->"###";
	public TerminalRule getML_COMMENTRule() {
		return gaCoffeeScript.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"#" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaCoffeeScript.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return gaCoffeeScript.getWSRule();
	} 

	//// Put it at the end, so keywords will be matched earlier
	//// }}} end of terminals
	//// vim: set fdm=marker:
	//terminal IDENTIFIER:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDENTIFIERRule() {
		return gaCoffeeScript.getIDENTIFIERRule();
	} 
}
