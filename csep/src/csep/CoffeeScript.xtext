grammar csep.CoffeeScript hidden(WS)//with csep.Tokens
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coffeeScript "http://www.coffeescript.org/eclipse"

Root
  : Body
  | Block TERMINATOR
  ;

Body:
	lines+=Line (TERMINATOR lines+=Line?)*;

Line:
	Stmt |
	Expression;
	
Stmt:
	ReturnStmt |
	ThrowStmt;
	
ReturnStmt:
	RETURN exp=Expression;
	
ThrowStmt:
	THROW exp=Expression;
	
Expression:
	PostfixIf;
	
// right-assoc
// Note: the lexer seems to know it should give a POST_IF token here
PostfixIf returns Expression:
	Assignment (=>({PostfixIf.truePart=current} operator=(POST_IF | IF)) condition=Expression)?;

Assignment returns Expression:
	{Assignment} (=>(left=Assignable operator=(EQUAL | COMPOUND_ASSIGN)) right=Expression) |
	LogicOp;

LogicOp returns Expression:
 	CompareOp (=>({BinaryExp.left=current} operator=LOGIC) right=CompareOp)*;
  
CompareOp returns Expression:
  RelationOp (=>({BinaryExp.left=current} operator=COMPARE) right=RelationOp)*;

RelationOp returns Expression:
  ShiftOp (=>({BinaryExp.left=current} operator=RELATION) right=ShiftOp)*;

ShiftOp returns Expression:
  AdditiveOp (=>({BinaryExp.left=current} operator=SHIFT) right=AdditiveOp)*;

AdditiveOp returns Expression:
  MathOp (=>({BinaryExp.left=current} operator=(PLUS | MINUS)) right=MathOp)*;

MathOp returns Expression:
  UnaryOp (=>({BinaryExp.left=current} operator=MATH) right=UnaryOp)*;

UnaryOp returns Expression:
	(UNARY | PLUS | MINUS) Expression |
	(PLUS_PLUS | MINUS_MINUS) Variable |
	// FIXME: postfix increment
	Application QUESTION?;
	
// Nested function calls and property accesses -- I couldn't come up with a better name
Application:
	value=PrimaryExpression features+=FeatureCall*;
	
FeatureCall:
	FunctionCall |
	PropertyAccess;
	
FunctionCall:
	{FunctionCall} FUNC_EXIST? CALL_START CALL_END;
	
PropertyAccess:
	NamedPropertyAccess |
	IndexedPropertyAccess;
	
NamedPropertyAccess:	
	(accessor=(DOT | QUESTION_DOT) name=Id) |
	(accessor=DOUBLE_COLON name=Id?);

IndexedPropertyAccess:
	INDEX_START index=Index INDEX_END;
	
Index:
	(=>(dots=DOT_DOT) end=Expression) |
	(=>(start=Expression dots=DOT_DOT) end=Expression?) |
	exp=Expression;
	
PrimaryExpression:
	IfExp |
	Parenthetical |
	Literal |
	Array |
	Id;
	
Block
  : {Block} INDENT Body? OUTDENT
  ;
  
IfExp
  : blocks+=CondBlock (ELSE blocks+=CondBlock)* (ELSE defaultBlock=Block)?
  ;

// IF can be 'if' or 'unless'
CondBlock: operator=IF condition=Expression action=Block;

Id: name=IDENTIFIER;

Property:
	// FIXME: property is actually "Expression DOT Id"
	Id DOT prop=Id;
	
Variable:
	Id |
	Property;

Assignable:
    Variable;
	/*
	 * FIXME: handle more complex assignables
	 *
	Array;
	*/
	
Arg:
	exp=Expression splat?=ELLIPSIS?;
	
ArgLine:
	head=Arg (COMMA tail+=Arg)* COMMA?;
	
ExplicitArgList:
	lines+=ArgLine ((TERMINATOR lines+=ArgLine) | (INDENT lines+=ArgLine OUTDENT))*;
	
ArgList:
	{ArgList} (dummy=ExplicitArgList | (INDENT dummy=ExplicitArgList OUTDENT))?;
	
Array:
	=>LBRACKET ArgList RBRACKET;
	
NumberLiteral:
	{NumberLiteral} NUMBER;

StringLiteral:
	{StringLiteral} STRING;

BoolLiteral:
	{BoolLiteral} BOOL;

Literal
  : NumberLiteral
  | StringLiteral
  | BoolLiteral
  ;

Parenthetical:
	=>LPAREN content=Body RPAREN;
 
// terminals {{{
/* Note: these are only to enable debugging with Antlworks,
 * The actual tokens are provided by the lexer.
 * The debugger is smart in some cases, and emits different tokens
 * for the same character depending on the context.
 * For example
 * "(1)" -> LPAREN NUMBER RPAREN
 * "func()" -> IDENTIFIER CALL_START CALL_END
 * But the debugger expects different strings for the tokens,
 * so special ones get an additional asterisk:
 * LPAREN: '('
 * CALL_START: '(*'
 * 
 * To imitate indentation while debugging, use INDENT and OUTDENT, like this
 *   if maybe {*
 *     action()
 *   *}
 *   else {*
 *     wait()
 *   *}
 */
// compound terminals at the beginning to they don't get shadowed
terminal ELLIPSIS: '...';
terminal DOT_DOT: '..';
terminal DOUBLE_COLON: '::';
terminal SHIFT: '<<' | '>>';
terminal COMPARE : '<' | '==' | '>' | '<=' | '>=' | '!=';
terminal COMPOUND_ASSIGN: '+=' | '-=';
terminal PLUS_PLUS: '++';
terminal MINUS_MINUS: '--';

terminal AT_SIGIL: '@';
terminal BOOL: 'true' | 'false' | 'undefined' | 'null';
terminal BOUND_FUNC_ARROW: 'dummy BOUND_FUNC_ARROW';
terminal BY: 'dummy BY';
terminal CALL_END: '*)';
terminal CALL_START: '(*';
terminal CATCH: 'dummy CATCH';
terminal CLASS: 'class';
terminal COLON: ':';
terminal COLON_SLASH: 'dummy COLON_SLASH';
terminal COMMA: 'dummy COMMA';
terminal DOT: '.';
terminal ELSE: 'else';
terminal EQUAL: '=';
terminal EXTENDS: 'dummy EXTENDS';
terminal FINALLY: 'dummy FINALLY';
terminal FOR: 'dummy FOR';
terminal FORIN: 'dummy FORIN';
terminal FOROF: 'dummy FOROF';
terminal FUNC_ARROW: 'dummy FUNC_ARROW';
terminal FUNC_EXIST: 'dummy FUNC_EXIST';
terminal HERECOMMENT: 'dummy HERECOMMENT';
terminal IF: 'if' | 'unless';
terminal INDENT: '{*';
terminal INDEX_END: '*]';
terminal INDEX_PROTO: 'dummy INDEX_PROTO';
terminal INDEX_SOAK: 'dummy INDEX_SOAK';
terminal INDEX_START: '[*';
terminal JS: 'dummy JS';
terminal LBRACKET: '[';
terminal LCURLY: 'dummy LCURLY';
terminal LEADING_WHEN: 'dummy LEADING_WHEN';
terminal LOGIC: '&&' | '||';
terminal LOOP: 'dummy LOOP';
terminal LPAREN: '(';
terminal MATH: '*' | '/';
terminal MINUS: '-';
terminal NEW: 'dummy NEW';
terminal NUMBER returns ecore::EInt: ('0'..'9')+;
terminal OUTDENT: '*}';
terminal OWN: 'dummy OWN';
terminal PARAM_END: 'dummy PARAM_END';
terminal PARAM_START: 'dummy PARAM_START';
terminal PLUS: '+';
terminal POST_IF: 'dummy POST_IF'; // practically the same as IF
terminal QUESTION: '?';
terminal QUESTION_DOT: '?.';
terminal RBRACKET: ']';
terminal RCURLY: 'dummy RCURLY';
terminal REGEX: 'dummy REGEX';
terminal RELATION: 'in' | 'of' | 'instanceof'; 
terminal RETURN: 'return';
terminal RPAREN: ')';
terminal STATEMENT: 'dummy STATEMENT';
terminal STRING: '"' (('a'..'z') | ' ')* '"';
terminal SUPER: 'dummy SUPER';
terminal SWITCH: 'dummy SWITCH';
terminal TERMINATOR: '\n'+;
terminal THEN: 'dummy THEN';
terminal THIS: 'dummy THIS';
terminal THROW: 'throw';
terminal TRY: 'dummy TRY';
terminal UNARY: '!' | '~' | 'new';
terminal UNTIL: 'dummy UNTIL';
terminal WHEN: 'dummy WHEN';
terminal WHILE: 'dummy WHILE';

// Put it at the end, so keywords will be matched earlier
terminal IDENTIFIER: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal WS			: (' '|'\t')+;
// }}} end of terminals
// vim: set fdm=marker:
