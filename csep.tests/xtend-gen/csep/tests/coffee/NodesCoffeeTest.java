package csep.tests.coffee;

import csep.tests.ParserTestBase;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.junit.Test;

@SuppressWarnings("all")
public class NodesCoffeeTest extends ParserTestBase {
  /**
   * Even the original coffee has problems parsing it
   */
  @Test
  public void testClosure() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#### Closure");
    _builder.newLine();
    _builder.newLine();
    _builder.append("# A faux-node used to wrap an expressions body in a closure.");
    _builder.newLine();
    _builder.append("METHOD_DEF = ///");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("^");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("(?:");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("(#{IDENTIFIER_STR})");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("\\.prototype");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("(?:");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("\\.(#{IDENTIFIER_STR})");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("| \\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|\'(?:[^\\\\\'\\r\\n]|\\\\.)*\')\\]");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("| \\[(0x[\\da-fA-F]+ | \\d*\\.?\\d+ (?:[eE][+-]?\\d+)?)\\]");
    _builder.newLine();
    _builder.append("      ");
    _builder.append(")");
    _builder.newLine();
    _builder.append("    ");
    _builder.append(")");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("|");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("(#{IDENTIFIER_STR})");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("$");
    _builder.newLine();
    _builder.append("///");
    _builder.newLine();
    this.shouldBeOk(_builder);
  }
  
  /**
   * @see {MissingFeaturesTest.testKeywordAsFeatureName}
   */
  @Test
  public void testOp() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#### Op");
    _builder.newLine();
    _builder.newLine();
    _builder.append("# Simple Arithmetic and logical operations. Performs some conversion from");
    _builder.newLine();
    _builder.append("# CoffeeScript operations into their JavaScript equivalents.");
    _builder.newLine();
    _builder.append("exports.Op = class Op extends Base");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("constructor: (op, first, second, flip ) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return new In first, second if op is \'in\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if op is \'do\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("call = new Call first, first.params or []");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("## workaround for: call.do = yes");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("call[\'do\'] = yes");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("return call");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if op is \'new\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("return first.newInstance() if first instanceof Call and not first.do and not first.isNew");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("first = new Parens first   if first instanceof Code and first.bound or first.do");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@operator = CONVERSIONS[op] or op");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@first    = first");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@second   = second");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@flip     = !!flip");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return this");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# The map of conversions from CoffeeScript to JavaScript symbols.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("CONVERSIONS =");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\'==\': \'===\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\'!=\': \'!==\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\'of\': \'in\'");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# The map of invertible operators.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("INVERSIONS =");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\'!==\': \'===\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\'===\': \'!==\'");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("children: [\'first\', \'second\']");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("isSimpleNumber: NO");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("isUnary: ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("not @second");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("isComplex: ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("not (@isUnary() and (@operator in [\'+\', \'-\'])) or @first.isComplex()");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Am I capable of");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# [Python-style comparison chaining](http://docs.python.org/reference/expressions.html#notin)?");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("isChainable: ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@operator in [\'<\', \'>\', \'>=\', \'<=\', \'===\', \'!==\']");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("invert: ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if @isChainable() and @first.isChainable()");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("allInvertable = yes");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("curr = this");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("while curr and curr.operator");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("allInvertable and= (curr.operator of INVERSIONS)");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("curr = curr.first");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("return new Parens(this).invert() unless allInvertable");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("curr = this");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("while curr and curr.operator");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("curr.invert = !curr.invert");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("curr.operator = INVERSIONS[curr.operator]");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("curr = curr.first");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("this");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else if op = INVERSIONS[@operator]");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@operator = op");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if @first.unwrap() instanceof Op");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("@first.invert()");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("this");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else if @second");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("new Parens(this).invert()");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else if @operator is \'!\' and (fst = @first.unwrap()) instanceof Op and");
    _builder.newLine();
    _builder.append("                                  ");
    _builder.append("fst.operator in [\'!\', \'in\', \'instanceof\']");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("fst");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("new Op \'!\', this");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("unfoldSoak: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@operator in [\'++\', \'--\', \'delete\'] and unfoldSoak o, this, \'first\'");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileNode: (o) ->    ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("isChain = @isChainable() and @first.isChainable()");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("# In chains, there\'s no need to wrap bare obj literals in parens, ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("# as the chained expression is wrapped.");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@first.front = @front unless isChain");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return @compileUnary     o if @isUnary()");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return @compileChain     o if isChain");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return @compileExistence o if @operator is \'?\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("code = @first.compile(o, LEVEL_OP) + \' \' + @operator + \' \' +");
    _builder.newLine();
    _builder.append("           ");
    _builder.append("@second.compile(o, LEVEL_OP)");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if o.level <= LEVEL_OP then code else \"(#{code})\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Mimic Python\'s chained comparisons when multiple comparison operators are");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# used sequentially. For example:");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("#");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("#     bin/coffee -e \'console.log 50 < 65 > 10\'");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("#     true");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileChain: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("[@first.second, shared] = @first.second.cache o");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("fst = @first.compile o, LEVEL_OP");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("code = \"#{fst} #{if @invert then \'&&\' else \'||\'} #{ shared.compile o } #{@operator} #{ @second.compile o, LEVEL_OP }\"");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("\"(#{code})\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileExistence: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if @first.isComplex()");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("ref = new Literal o.scope.freeVariable \'ref\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("fst = new Parens new Assign ref, @first");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("fst = @first");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("ref = fst");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("new If(new Existence(fst), ref, type: \'if\').addElse(@second).compile o");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Compile a unary **Op**.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileUnary: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("parts = [op = @operator]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("plusMinus = op in [\'+\', \'-\']");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("parts.push \' \' if op in [\'new\', \'typeof\', \'delete\'] or");
    _builder.newLine();
    _builder.append("                      ");
    _builder.append("plusMinus and @first instanceof Op and @first.operator is op");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if (plusMinus && @first instanceof Op) or (op is \'new\' and @first.isStatement o)");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@first = new Parens @first ");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("parts.push @first.compile o, LEVEL_OP");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("parts.reverse() if @flip");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("parts.join \'\'");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("toString: (idt) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("super idt, @constructor.name + \' \' + @operator");
    _builder.newLine();
    _builder.newLine();
    this.ok(_builder);
  }
  
  @Test
  public void testArr() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#### Arr");
    _builder.newLine();
    _builder.newLine();
    _builder.append("# An array literal.");
    _builder.newLine();
    _builder.append("exports.Arr = class Arr extends Base");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("constructor: (objs) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@objects = objs or []");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("children: [\'objects\']");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("filterImplicitObjects: Call::filterImplicitObjects");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileNode: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return \'[]\' unless @objects.length");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("o.indent += TAB");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("objs = @filterImplicitObjects @objects");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return code if code = Splat.compileSplattedArray o, objs");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("code = (obj.compile o, LEVEL_LIST for obj in objs).join \', \'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if code.indexOf(\'\\n\') >= 0");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("\"[\\n#{o.indent}#{code}\\n#{@tab}]\"");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("\"[#{code}]\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("assigns: (name) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("for obj in @objects when obj.assigns name then return yes");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("no");
    _builder.newLine();
    _builder.newLine();
    this.ok(_builder);
  }
  
  /**
   * @see {MissingFeaturesTest.testCompoundAssignable}
   */
  @Test
  public void testObj() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#### Obj");
    _builder.newLine();
    _builder.newLine();
    _builder.append("# An object literal, nothing fancy.");
    _builder.newLine();
    _builder.append("exports.Obj = class Obj extends Base");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("constructor: (props, @generated = false) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@objects = @properties = props or []");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("children: [\'properties\']");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileNode: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("props = @properties");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return (if @front then \'({})\' else \'{}\') unless props.length");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if @generated");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("for node in props when node instanceof Value");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("throw new Error \'cannot have an implicit value in an implicit object\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("idt         = o.indent += TAB");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("lastNoncom  = @lastNonComment @properties");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("props = for prop, i in props");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("join = if i is props.length - 1");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("\'\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("else if prop is lastNoncom or prop instanceof Comment");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("\'\\n\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("\',\\n\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("indent = if prop instanceof Comment then \'\' else idt");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if prop instanceof Value and prop.this");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("prop = new Assign prop.properties[0].name, prop, \'object\'");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if prop not instanceof Comment");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("if prop not instanceof Assign");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("prop = new Assign prop, prop, \'object\'");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("# Workaround for: (prop.variable.base or prop.variable).asKey = yes");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("vari = prop.variable.base or prop.variable");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("vari.asKey = yes");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("indent + prop.compile(o, LEVEL_TOP) + join");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("props = props.join \'\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("obj   = \"{#{ props and \'\\n\' + props + \'\\n\' + @tab }}\"");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if @front then \"(#{obj})\" else obj");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("assigns: (name) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("for prop in @properties when prop.assigns name then return yes");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("no");
    _builder.newLine();
    _builder.newLine();
    this.ok(_builder);
  }
  
  @Test
  public void testClass() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("#### Class");
    _builder.newLine();
    _builder.newLine();
    _builder.append("# The CoffeeScript class definition.");
    _builder.newLine();
    _builder.append("# Initialize a **Class** with its name, an optional superclass, and a");
    _builder.newLine();
    _builder.append("# list of prototype property assignments.");
    _builder.newLine();
    _builder.append("exports.Class = class Class extends Base");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("constructor: (@variable, @parent, @body = new Block) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@boundFuncs = []");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.classBody = yes");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("children: [\'variable\', \'parent\', \'body\']");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Figure out the appropriate name for the constructor function of this class.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("determineName: ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("return null unless @variable");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("decl = if tail = last @variable.properties");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("tail instanceof Access and tail.name.value");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@variable.base.value");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("decl and= IDENTIFIER.test(decl) and decl");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# For all `this`-references and bound functions in the class definition,");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# `this` is the Class being constructed.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("setContext: (name) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.traverseChildren false, (node) ->");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("return false if node.classBody");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if node instanceof Literal and node.value is \'this\'");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("node.value    = name");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("else if node instanceof Code");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("node.klass    = name");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("node.context  = name if node.bound");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Ensure that all functions bound to the instance are proxied in the");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# constructor.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("addBoundFunctions: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if @boundFuncs.length");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("for bvar in @boundFuncs");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("lhs = (new Value (new Literal \"this\"), [new Access bvar]).compile o");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("@ctor.body.unshift new Literal \"#{lhs} = #{utility \'bind\'}(#{lhs}, this)\"");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Merge the properties from a top-level object as prototypal properties");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# on the class.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("addProperties: (node, name, o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("props = node.base.properties[0..]");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("exprs = while assign = props.shift()");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if assign instanceof Assign");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("base = assign.variable.base");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("delete assign.context");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("func = assign.value");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("if base.value is \'constructor\'");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("if @ctor");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("throw new Error \'cannot define more than one constructor in a class\'");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("if func.bound");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("throw new Error \'cannot define a constructor as a bound function\'");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("if func instanceof Code");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("assign = @ctor = func");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("@externalCtor = o.scope.freeVariable \'class\'");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("assign = new Assign new Literal(@externalCtor), func");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("if assign.variable.this");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("func.static = yes");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("else");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("assign.variable = new Value(new Literal(name), [(new Access new Literal \'prototype\'), new Access base ])");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("if func instanceof Code and func.bound");
    _builder.newLine();
    _builder.append("              ");
    _builder.append("@boundFuncs.push base");
    _builder.newLine();
    _builder.append("              ");
    _builder.append("func.bound = no");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("assign");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("compact exprs");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Walk the body of the class, looking for prototype properties to be converted.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("walkBody: (name, o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@traverseChildren false, (child) =>");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("return false if child instanceof Class");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("if child instanceof Block");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("for node, i in exps = child.expressions");
    _builder.newLine();
    _builder.append("          ");
    _builder.append("if node instanceof Value and node.isObject(true)");
    _builder.newLine();
    _builder.append("            ");
    _builder.append("exps[i] = @addProperties node, name, o");
    _builder.newLine();
    _builder.append("        ");
    _builder.append("child.expressions = exps = flatten exps");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Make sure that a constructor is defined for the class, and properly");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# configured.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("ensureConstructor: (name) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("if not @ctor");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@ctor = new Code");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@ctor.body.push new Literal \"#{name}.__super__.constructor.apply(this, arguments)\" if @parent");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@ctor.body.push new Literal \"#{@externalCtor}.apply(this, arguments)\" if @externalCtor");
    _builder.newLine();
    _builder.append("      ");
    _builder.append("@body.expressions.unshift @ctor");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@ctor.ctor     = @ctor.name = name");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@ctor.klass    = null");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@ctor.noReturn = yes");
    _builder.newLine();
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# Instead of generating the JavaScript string directly, we build up the");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# equivalent syntax tree and compile that, in pieces. You can see the");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("# constructor, property assignments, and inheritance getting built out below.");
    _builder.newLine();
    _builder.append("  ");
    _builder.append("compileNode: (o) ->");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("decl  = @determineName()");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("name  = decl or @name or \'_Class\'");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("name = \"_#{name}\" if name.reserved");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("lname = new Literal name");
    _builder.newLine();
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@setContext name");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@walkBody name, o");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@ensureConstructor name");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.spaced = yes");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.expressions.unshift new Extends lname, @parent if @parent");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.expressions.unshift @ctor unless @ctor instanceof Code");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@body.expressions.push lname");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("@addBoundFunctions o");
    _builder.newLine();
    _builder.newLine();
    _builder.append("    ");
    _builder.append("klass = new Parens Closure.wrap(@body), true");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("klass = new Assign @variable, klass if @variable");
    _builder.newLine();
    _builder.append("    ");
    _builder.append("klass.compile o");
    _builder.newLine();
    _builder.newLine();
    this.ok(_builder);
  }
}
